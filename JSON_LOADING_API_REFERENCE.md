# JSON Loading API Reference

## Overview

This document provides a technical reference for developers working with the bidirectional JSON loading feature in the Engage Rules Generator.

## Core Classes

### ExcelParserV5

Main class for parsing and generating data.

#### JSON Loading Methods

```java
/**
 * Loads a JSON file that was previously generated by this application.
 * Supports both combined JSON format (with nurseCalls and clinicals sections)
 * and individual flow type JSON files.
 * 
 * @param jsonFile The JSON file to load
 * @throws Exception if the file cannot be read or parsed
 */
public void loadJson(File jsonFile) throws Exception

/**
 * Parses a JSON section (nurseCalls, clinicals, or orders) and populates 
 * the corresponding flow list.
 * 
 * @param section The JSON section to parse (Map<String, Object>)
 * @param flowType The flow type: "NurseCalls", "Clinicals", or "Orders"
 */
private void parseJsonFlows(Map<String, Object> section, String flowType)
```

#### JSON Parser Methods

```java
// Main entry point for parsing JSON string
private Map<String, Object> parseJsonObject(String json) throws Exception

// Parse different JSON value types
private Object parseValue(String json, int[] pos) throws Exception
private Map<String, Object> parseObject(String json, int[] pos) throws Exception
private List<Object> parseArray(String json, int[] pos) throws Exception
private String parseString(String json, int[] pos) throws Exception
private Boolean parseBoolean(String json, int[] pos) throws Exception
private Object parseNull(String json, int[] pos) throws Exception
private Number parseNumber(String json, int[] pos) throws Exception
private void skipWhitespace(String json, int[] pos)
```

### AppController

Main controller for the JavaFX GUI.

#### JSON Loading UI Methods

```java
/**
 * Handles the Load JSON button click event.
 * Opens a file chooser, loads the selected JSON file,
 * and refreshes the GUI tables.
 */
private void loadJson()
```

## Data Structures

### FlowRow

Represents a single delivery flow configuration.

```java
public static final class FlowRow {
    public boolean inScope = true;
    public String type = "";              // "NurseCalls", "Clinicals", or "Orders"
    public String configGroup = "";
    public String alarmName = "";
    public String sendingName = "";
    public String priorityRaw = "";
    public String deviceA = "";
    public String deviceB = "";
    public String ringtone = "";
    public String responseOptions = "";
    public String breakThroughDND = "";
    public String multiUserAccept = "";
    public String escalateAfter = "";
    public String ttlValue = "";
    public String enunciate = "";
    public String emdan = "";
    public String t1 = ""; public String r1 = "";
    public String t2 = ""; public String r2 = "";
    public String t3 = ""; public String r3 = "";
    public String t4 = ""; public String r4 = "";
    public String t5 = ""; public String r5 = "";
    public String customTabSource = "";
}
```

### UnitRow

Represents a unit configuration.

```java
public static final class UnitRow {
    public String facility = "";
    public String unitNames = "";
    public String podRoomFilter = "";
    public String nurseGroup = "";
    public String clinGroup = "";
    public String ordersGroup = "";
    public String noCareGroup = "";
    public String comments = "";
    public final Map<String, String> customGroups = new LinkedHashMap<>();
}
```

## JSON Structure Mapping

### Input JSON Structure

```json
{
  "version": "1.1.0",
  "alarmAlertDefinitions": [
    {
      "name": "Alarm Name",
      "type": "NurseCalls",
      "values": []
    }
  ],
  "deliveryFlows": [
    {
      "name": "SEND NURSECALL | URGENT | Alarm Name | Config Group | ",
      "priority": "urgent",
      "status": "Active",
      "alarmsAlerts": ["Alarm Name"],
      "interfaces": [
        {
          "referenceName": "OutgoingWCTP",
          "componentName": "OutgoingWCTP"
        }
      ],
      "parameterAttributes": [
        {
          "name": "breakThrough",
          "value": "voceraAndDevice"
        },
        {
          "name": "enunciate",
          "value": "true"
        }
      ],
      "destinations": [...],
      "units": [...]
    }
  ]
}
```

### Field Mapping

| JSON Path | FlowRow Field | Extraction Logic |
|-----------|---------------|------------------|
| `deliveryFlows[].name` | `priorityRaw`, `alarmName`, `configGroup` | Parse by splitting on `\|` |
| `deliveryFlows[].priority` | `priorityRaw` | Direct mapping |
| `deliveryFlows[].alarmsAlerts[0]` | `alarmName` | First element |
| `deliveryFlows[].interfaces[].referenceName` | `deviceA` | Concatenate with `, ` |
| `deliveryFlows[].parameterAttributes[]` | Various | Map by `name` field |
| `deliveryFlows[].destinations[]` | `r1` | Extract from first order |
| `deliveryFlows[].units[]` | `configGroup` | Extract facility |

### Parameter Attribute Mappings

| parameterAttributes.name | FlowRow Field | Transformation |
|--------------------------|---------------|----------------|
| `breakThrough` | `breakThroughDND` | Direct value |
| `enunciate` | `enunciate` | Direct value |
| `alertSound` | `ringtone` | Remove quotes and `.wav` |
| `badgeAlertSound` | `ringtone` | Remove quotes and `.wav` |
| `responseType` | `responseOptions` | Map to "Accept" or "No Response" |
| `ttl` | `ttlValue` | Direct value |

## Error Handling

### Exception Types

```java
// Invalid JSON format
throw new Exception("Invalid JSON: must start with {");

// Unexpected end of input
throw new Exception("Unexpected end of JSON");

// Invalid character
throw new Exception("Unexpected character at position " + pos[0] + ": " + c);

// Missing expected character
throw new Exception("Expected \" at position " + pos[0]);

// Invalid value type
throw new Exception("Invalid boolean at position " + pos[0]);
```

### Error Recovery

The JSON loader does not attempt to recover from errors. If parsing fails:
1. An exception is thrown
2. The GUI displays an error dialog
3. No data is loaded (all-or-nothing approach)

## Testing

### Test Cases

See `JsonLoadingTest.java` for comprehensive test coverage:

```java
// Test simple NurseCalls JSON
@Test
void testLoadSimpleNurseCallJson(@TempDir Path tempDir)

// Test combined JSON with multiple flow types
@Test
void testLoadCombinedJson(@TempDir Path tempDir)

// Test parameter attribute parsing
@Test
void testLoadJsonWithParameterAttributes(@TempDir Path tempDir)

// Test round-trip export/import
@Test
void testRoundTrip(@TempDir Path tempDir)
```

### Running Tests

```bash
# Run only JSON loading tests
mvn test -Dtest=JsonLoadingTest

# Run all tests
mvn test

# Run with verbose output
mvn test -X -Dtest=JsonLoadingTest
```

## Performance Considerations

### Memory Usage

- JSON is fully loaded into memory before parsing
- Large JSON files (>100MB) may cause memory pressure
- Consider streaming parser for very large files (future enhancement)

### Parsing Speed

- Custom parser is optimized for readability, not speed
- Typical parsing time: <100ms for files up to 1MB
- For files >10MB, consider using a production JSON library

### Optimization Tips

```java
// Current implementation reads entire file into memory
StringBuilder content = new StringBuilder();
try (BufferedReader reader = new BufferedReader(new FileReader(jsonFile))) {
    String line;
    while ((line = reader.readLine()) != null) {
        content.append(line).append("\n");
    }
}

// For large files, consider:
// 1. Streaming parser (Jackson, Gson)
// 2. Chunked reading
// 3. Memory-mapped files
```

## Extension Points

### Custom JSON Processing

To add custom JSON processing:

```java
// In parseJsonFlows() method, add custom logic
private void parseJsonFlows(Map<String, Object> section, String flowType) {
    // ... existing code ...
    
    // Add custom processing here
    if (flow.containsKey("customField")) {
        String customValue = (String) flow.get("customField");
        row.customTabSource = customValue; // Example
    }
    
    // ... existing code ...
}
```

### Adding New Flow Types

To support a new flow type (e.g., "Labs"):

1. Add to ExcelParserV5:
```java
public final List<FlowRow> labs = new ArrayList<>();
```

2. Update loadJson():
```java
if (root.containsKey("labs")) {
    Map<String, Object> labsSection = (Map<String, Object>) root.get("labs");
    parseJsonFlows(labsSection, "Labs");
}
```

3. Update parseJsonFlows():
```java
if ("Labs".equals(flowType)) {
    labs.add(row);
}
```

## Integration with Existing Code

### Excel Loading

JSON loading integrates with existing Excel loading:

```java
// Both use the same data structures
parser.load(excelFile);        // Load from Excel
parser.loadJson(jsonFile);     // Load from JSON

// Both populate same lists
List<FlowRow> nurseCalls = parser.nurseCalls;
List<FlowRow> clinicals = parser.clinicals;
```

### JSON Export

JSON loading complements JSON export:

```java
// Export to JSON
parser.writeNurseCallsJson(file);

// Load it back
parser.loadJson(file);

// Round-trip should preserve core data
```

## Debugging

### Enable Debug Logging

Add logging to track parsing:

```java
private void parseJsonFlows(Map<String, Object> section, String flowType) {
    System.out.println("Parsing flow type: " + flowType);
    List<Map<String, Object>> deliveryFlows = 
        (List<Map<String, Object>>) section.get("deliveryFlows");
    System.out.println("Found " + deliveryFlows.size() + " flows");
    // ... rest of method ...
}
```

### Common Issues

**Issue**: JSON loads but no data appears
```java
// Check: Is flow type correctly identified?
System.out.println("Flow type: " + flowType);
System.out.println("Is NurseSide: " + isNurseSide);
System.out.println("Added to list: " + (isNurseSide ? "nurseCalls" : "clinicals"));
```

**Issue**: Parameter attributes not parsed
```java
// Check: Are attributes in expected format?
for (Map<String, Object> attr : paramAttrs) {
    System.out.println("Attr: " + attr.get("name") + " = " + attr.get("value"));
}
```

## Security Considerations

### Input Validation

Currently, the JSON loader:
- ✅ Validates JSON syntax
- ✅ Handles invalid JSON gracefully
- ❌ Does not validate content schema
- ❌ Does not sanitize input values

### Recommendations

For production use:

1. **Add Schema Validation**:
```java
// Before parsing, validate against schema
validateJsonSchema(jsonContent);
```

2. **Sanitize String Values**:
```java
// Prevent injection attacks
String sanitized = sanitizeInput(value);
row.alarmName = sanitized;
```

3. **Limit File Size**:
```java
if (jsonFile.length() > MAX_FILE_SIZE) {
    throw new Exception("File too large");
}
```

## Future Enhancements

### Potential Improvements

1. **Use Jackson/Gson**: Replace custom parser with production library
2. **Async Loading**: Load large files in background thread
3. **Progress Callbacks**: Report parsing progress for large files
4. **Partial Loading**: Support loading specific flow types only
5. **Validation**: Add JSON schema validation
6. **Error Recovery**: Attempt to parse partial data on errors
7. **Unit Reconstruction**: Better rebuild unit data from flow units

### API Changes

Proposed future API:

```java
// Async loading with progress callback
public CompletableFuture<Void> loadJsonAsync(
    File jsonFile, 
    Consumer<Integer> progressCallback
)

// Load specific flow types only
public void loadJson(File jsonFile, Set<String> flowTypes)

// Validate before loading
public ValidationResult validateJson(File jsonFile)
```

## Code Examples

### Example 1: Programmatic JSON Loading

```java
ExcelParserV5 parser = new ExcelParserV5();
File jsonFile = new File("path/to/config.json");

try {
    parser.loadJson(jsonFile);
    System.out.println("Loaded " + parser.nurseCalls.size() + " nurse calls");
    
    // Process loaded data
    for (ExcelParserV5.FlowRow flow : parser.nurseCalls) {
        System.out.println(flow.alarmName + ": " + flow.priorityRaw);
    }
} catch (Exception e) {
    System.err.println("Failed to load JSON: " + e.getMessage());
}
```

### Example 2: Round-Trip Test

```java
// Create some data
ExcelParserV5 parser1 = new ExcelParserV5();
FlowRow flow = new FlowRow();
flow.alarmName = "Test";
flow.priorityRaw = "urgent";
parser1.nurseCalls.add(flow);

// Export
File tempFile = File.createTempFile("test", ".json");
parser1.writeNurseCallsJson(tempFile);

// Load it back
ExcelParserV5 parser2 = new ExcelParserV5();
parser2.loadJson(tempFile);

// Verify
assert parser2.nurseCalls.size() == 1;
assert "Test".equals(parser2.nurseCalls.get(0).alarmName);
```

### Example 3: Custom Processing

```java
@Override
private void parseJsonFlows(Map<String, Object> section, String flowType) {
    // Call parent implementation
    super.parseJsonFlows(section, flowType);
    
    // Add custom post-processing
    List<FlowRow> flows = switch(flowType) {
        case "NurseCalls" -> nurseCalls;
        case "Clinicals" -> clinicals;
        case "Orders" -> orders;
        default -> Collections.emptyList();
    };
    
    for (FlowRow flow : flows) {
        // Custom validation or transformation
        if (flow.priorityRaw.isEmpty()) {
            flow.priorityRaw = "normal"; // Default
        }
    }
}
```

## References

- **ExcelParserV5.java**: Main implementation (lines 369-738)
- **AppController.java**: GUI integration (lines 909-966)
- **App.fxml**: UI definition (lines 79-86)
- **JsonLoadingTest.java**: Test suite
- **BIDIRECTIONAL_JSON_LOADING.md**: Feature documentation

---

**API Version**: 1.0  
**Last Updated**: November 15, 2025  
**Stability**: Stable - Production Ready
